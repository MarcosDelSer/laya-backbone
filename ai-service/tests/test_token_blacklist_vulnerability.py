"""Reproduction test for token blacklist bypass vulnerability.

This test demonstrates the critical security issue where blacklisted tokens
continue to be accepted for authentication, allowing logged-out users or
compromised tokens to maintain access.

EXPECTED BEHAVIOR: This test should FAIL, demonstrating the vulnerability exists.
After the fix is implemented, this test should PASS.
"""

from datetime import datetime, timedelta, timezone
from unittest.mock import AsyncMock, MagicMock

import pytest
from fastapi import HTTPException
from fastapi.security import HTTPAuthorizationCredentials

# Import auth fixtures from auth.conftest
pytest_plugins = ["tests.auth.conftest"]

from app.auth.jwt import verify_token
from app.auth.service import AuthService
from app.auth.schemas import LoginRequest, LogoutRequest

from tests.auth.conftest import (
    create_access_token,
    create_refresh_token,
    create_token_blacklist_in_db,
    TEST_PASSWORD_PLAIN,
)


class TestTokenBlacklistVulnerability:
    """Reproduction tests demonstrating blacklisted tokens are accepted."""

    @pytest.mark.asyncio
    async def test_blacklisted_access_token_is_rejected(self, auth_db_session, teacher_user):
        """Test that blacklisted access token is rejected during verification.

        VULNERABILITY: Blacklisted tokens should be rejected but are currently accepted.
        This test should FAIL initially, demonstrating the security issue.
        """
        # Create a valid access token
        access_token = create_access_token(
            user_id=str(teacher_user.id),
            email=teacher_user.email,
            role=teacher_user.role.value,
        )

        # Blacklist the token (simulating logout or token revocation)
        await create_token_blacklist_in_db(
            auth_db_session,
            token=access_token,
            user_id=teacher_user.id,
            expires_at=datetime.now(timezone.utc) + timedelta(hours=1),
        )

        # Attempt to verify the blacklisted token
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials=access_token,
        )

        # This should raise HTTPException with 401 status
        # If the vulnerability exists, this will NOT raise an exception
        with pytest.raises(HTTPException) as exc_info:
            await verify_token(credentials, auth_db_session)

        # Verify the correct error is raised
        assert exc_info.value.status_code == 401
        assert "revoked" in exc_info.value.detail.lower()

    @pytest.mark.asyncio
    async def test_blacklisted_refresh_token_is_rejected(self, auth_db_session, teacher_user):
        """Test that blacklisted refresh token is rejected during token refresh.

        VULNERABILITY: Blacklisted refresh tokens should be rejected but may be accepted.
        This test should FAIL initially if the vulnerability exists.
        """
        mock_db = AsyncMock()

        # Create a valid refresh token
        refresh_token = create_refresh_token(user_id=str(teacher_user.id))

        # Simulate blacklisting the refresh token
        mock_blacklist = MagicMock()
        mock_blacklist_result = MagicMock()
        mock_blacklist_result.scalar_one_or_none.return_value = mock_blacklist
        mock_db.execute.return_value = mock_blacklist_result

        service = AuthService(mock_db)

        # Attempt to refresh using blacklisted token
        from app.auth.schemas import RefreshRequest
        refresh_request = RefreshRequest(refresh_token=refresh_token)

        # This should raise HTTPException with 401 status
        with pytest.raises(HTTPException) as exc_info:
            await service.refresh_tokens(refresh_request)

        assert exc_info.value.status_code == 401
        assert "revoked" in exc_info.value.detail.lower()

    @pytest.mark.asyncio
    async def test_logout_then_use_token_should_fail(self, auth_db_session, teacher_user):
        """Test complete logout flow: logout should prevent token reuse.

        VULNERABILITY: After logout, tokens should be unusable. This test verifies
        that logout properly blacklists tokens and they cannot be reused.
        This test should FAIL initially if the vulnerability exists.
        """
        # Step 1: Simulate login (create tokens)
        access_token = create_access_token(
            user_id=str(teacher_user.id),
            email=teacher_user.email,
            role=teacher_user.role.value,
        )
        refresh_token = create_refresh_token(user_id=str(teacher_user.id))

        # Step 2: Logout (blacklist both tokens)
        mock_db = AsyncMock()
        mock_db.commit = AsyncMock()

        service = AuthService(mock_db)
        logout_request = LogoutRequest(
            access_token=access_token,
            refresh_token=refresh_token,
        )

        logout_response = await service.logout(logout_request)

        # Verify logout succeeded
        assert logout_response.message == "Successfully logged out"
        assert logout_response.tokens_invalidated == 2

        # Step 3: Blacklist the access token in the test database
        await create_token_blacklist_in_db(
            auth_db_session,
            token=access_token,
            user_id=teacher_user.id,
            expires_at=datetime.now(timezone.utc) + timedelta(hours=1),
        )

        # Step 4: Attempt to use the blacklisted access token
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials=access_token,
        )

        # This should raise HTTPException - token has been revoked
        with pytest.raises(HTTPException) as exc_info:
            await verify_token(credentials, auth_db_session)

        assert exc_info.value.status_code == 401
        assert "revoked" in exc_info.value.detail.lower()

    @pytest.mark.asyncio
    async def test_multiple_blacklisted_tokens_all_rejected(self, auth_db_session, teacher_user):
        """Test that multiple blacklisted tokens for same user are all rejected.

        VULNERABILITY: User may have multiple active sessions. All should be
        invalidated when tokens are blacklisted.
        This test should FAIL initially if the vulnerability exists.
        """
        import asyncio

        # Create multiple tokens (simulating multiple sessions)
        # Add small delays to ensure different iat timestamps
        tokens = []
        for i in range(3):
            # Wait a bit to ensure different iat timestamps
            if i > 0:
                await asyncio.sleep(1.1)

            token = create_access_token(
                user_id=str(teacher_user.id),
                email=teacher_user.email,
                role=teacher_user.role.value,
            )
            tokens.append(token)

            # Blacklist each token
            await create_token_blacklist_in_db(
                auth_db_session,
                token=token,
                user_id=teacher_user.id,
                expires_at=datetime.now(timezone.utc) + timedelta(hours=1),
            )

        # Verify all blacklisted tokens are rejected
        for token in tokens:
            credentials = HTTPAuthorizationCredentials(
                scheme="Bearer",
                credentials=token,
            )

            with pytest.raises(HTTPException) as exc_info:
                await verify_token(credentials, auth_db_session)

            assert exc_info.value.status_code == 401
            assert "revoked" in exc_info.value.detail.lower()

    @pytest.mark.asyncio
    async def test_non_blacklisted_token_still_works(self, auth_db_session, teacher_user):
        """Test that non-blacklisted tokens continue to work.

        This is a sanity check to ensure the blacklist mechanism doesn't
        break normal authentication.
        """
        # Create a valid access token
        access_token = create_access_token(
            user_id=str(teacher_user.id),
            email=teacher_user.email,
            role=teacher_user.role.value,
        )

        # Do NOT blacklist this token

        # Attempt to verify the token
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials=access_token,
        )

        # This should succeed without raising an exception
        payload = await verify_token(credentials, auth_db_session)

        # Verify the payload is correct
        assert payload["sub"] == str(teacher_user.id)
        assert payload["email"] == teacher_user.email
        assert payload["role"] == teacher_user.role.value
        assert payload["type"] == "access"

    @pytest.mark.asyncio
    async def test_expired_blacklist_entry_allows_token_reuse(self, auth_db_session, teacher_user):
        """Test that tokens with expired blacklist entries can be reused.

        Note: In practice, JWT expiration should prevent this, but this tests
        that the blacklist cleanup logic works correctly.
        """
        # Create a valid access token with long expiration
        access_token = create_access_token(
            user_id=str(teacher_user.id),
            email=teacher_user.email,
            role=teacher_user.role.value,
            expires_delta_seconds=3600,  # 1 hour
        )

        # Blacklist the token with an expiration in the past
        await create_token_blacklist_in_db(
            auth_db_session,
            token=access_token,
            user_id=teacher_user.id,
            expires_at=datetime.now(timezone.utc) - timedelta(hours=1),  # Expired
        )

        # In a real system, the blacklist check should skip expired entries
        # This behavior depends on the implementation
        # For now, we expect the token to still be rejected because
        # the blacklist entry exists (even if expired)
        credentials = HTTPAuthorizationCredentials(
            scheme="Bearer",
            credentials=access_token,
        )

        # The current implementation doesn't filter by expires_at
        # So this will still be rejected
        with pytest.raises(HTTPException) as exc_info:
            await verify_token(credentials, auth_db_session)

        assert exc_info.value.status_code == 401
